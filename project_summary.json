{
  "project_name": "mtg_price_predictor",
  "timestamp": "2025-05-11T01:00:00",
  "version": "0.2.5",
  "data_handling": {
    "market_prices": {
      "direct_low": {
        "description": "Lowest direct price, key max price indicator",
        "strategy": "carry_forward",
        "method": "Fill NaNs with last known value per card_sku_id, then backfill",
        "stats": {
          "nan_count_granular": 89766,
          "nan_proportion_granular": 0.0136
        },
        "evaluation": "Minimal NaNs, preservesapt price trends."
      },
      "market": {
        "description": "Average market price",
        "strategy": "carry_forward",
        "method": "Fill NaNs with last known value per card_sku_id, then backfill",
        "stats": {
          "nan_count_granular": 0,
          "nan_proportion_granular": 0.0
        },
        "evaluation": "No NaNs, strategy effective."
      },
      "low": {
        "description": "Lowest price",
        "strategy": "carry_forward",
        "method": "Fill NaNs with last known value per card_sku_id, then backfill",
        "stats": {
          "nan_count_granular": 0,
          "nan_proportion_granular": 0.0
        },
        "evaluation": "No NaNs, suitable for price continuity."
      },
      "lowest_list": {
        "description": "Lowest listing price",
        "strategy": "carry_forward",
        "method": "Fill NaNs with last known value per card_sku_id, then backfill",
        "stats": {
          "nan_count_granular": 0,
          "nan_proportion_granular": 0.0
        },
        "evaluation": "No NaNs, strategy effective."
      }
    },
    "sales_history": {
      "sales_quantity": {
        "description": "Total sales quantity per day",
        "strategy": "current",
        "method": "Aggregate by card_sku_id and date, fill missing days with 0",
        "stats": {
          "nan_count_granular": 82438,
          "nan_proportion_granular": 0.0124,
          "non_zero_sales": 4528030,
          "correlation_with_direct_low": 0.0540
        },
        "evaluation": "Minimal NaNs, sufficient for model."
      },
      "sales_price_max": {
        "description": "Maximum sale price per day",
        "strategy": "current",
        "method": "Aggregate by card_sku_id and date, fill missing days with 0",
        "stats": {
          "nan_count_granular": 82438,
          "nan_proportion_granular": 0.0124,
          "non_zero_sales": 4528030,
          "correlation_with_direct_low": 0.0540
        },
        "evaluation": "Minimal NaNs, sufficient for model."
      }
    },
    "listings": {
      "price": {
        "description": "Listing price",
        "strategy": "carry_forward",
        "method": "Fill NaNs with last known value per card_sku_id, then backfill",
        "stats": {
          "nan_count_granular": 115920,
          "nan_proportion_granular": 0.0175
        },
        "evaluation": "Minimal NaNs, maintains price continuity."
      },
      "quantity": {
        "description": "Listing quantity",
        "strategy": "carry_forward",
        "method": "Fill NaNs with last known value per card_sku_id, then backfill",
        "stats": {
          "nan_count_granular": 115920,
          "nan_proportion_granular": 0.0175
        },
        "evaluation": "Minimal NaNs, suitable for inventory tracking."
      },
      "direct_inventory_count": {
        "description": "Direct inventory count",
        "strategy": "carry_forward",
        "method": "Fill NaNs with last known value per card_sku_id, then backfill",
        "stats": {
          "nan_count_granular": 115920,
          "nan_proportion_granular": 0.0175
        },
        "evaluation": "Minimal NaNs, suitable for inventory tracking."
      }
    },
    "card_attributes": {
      "set_name": {
        "description": "Card set name",
        "strategy": "carry_forward",
        "method": "Fill NaNs with last known value per card_sku_id",
        "stats": {
          "nan_count_granular": 0,
          "nan_proportion_granular": 0.0
        },
        "evaluation": "Minimal NaNs, strategy effective."
      },
      "rarity": {
        "description": "Card rarity",
        "strategy": "carry_forward",
        "method": "Fill NaNs with last known value per card_sku_id",
        "stats": {
          "nan_count_granular": 0,
          "nan_proportion_granular": 0.0
        },
        "evaluation": "Minimal NaNs, strategy effective."
      },
      "condition": {
        "description": "Card condition",
        "strategy": "carry_forward",
        "method": "Fill NaNs with last known value per card_sku_id",
        "stats": {
          "nan_count_granular": 0,
          "nan_proportion_granular": 0.0
        },
        "evaluation": "Minimal NaNs, strategy effective."
      }
    },
    "pipeline": {
      "description": "Pipeline orchestrates data fetching and merging with modular switches",
      "strategy": "modular_with_switches",
      "method": "pipeline.py runs modules (fetch_market_data, merge_data) with argparse switches to enable/disable for testing",
      "stats": {
        "modules_implemented": ["fetch_market_data", "merge_data"],
        "modules_pending": ["clean_data", "feature_engineering", "train_model", "predict", "evaluate_model"]
      },
      "evaluation": "Ensures modularity and testing flexibility, integrates merge_data.py seamlessly."
    },
    "issues": [
      {
        "description": "merge_data.py initially designed as standalone, risking pipeline integrity",
        "resolution": "Designed pipeline.py with switches to integrate merge_data as a module, maintaining standalone testing capability"
      }
    ]
  }
}